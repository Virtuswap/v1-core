// SPDF-License-Identifier: MIT

pragma solidity ^0.8.0;

import '../interfaces/IvFlashSwapCallback.sol';
import '../interfaces/IvPair.sol';
import '../types.sol';

contract ReentrancyExploiter is IvFlashSwapCallback {
    uint256 public constant SOME_AMOUNT = 100;

    struct MyCallbackData {
        address caller;
        address pool;
        bytes4 selector;
    }

    function vFlashSwapCallback(
        address tokenIn,
        address tokenOut,
        uint256 requiredBackAmount,
        bytes calldata data
    ) external override {
        MyCallbackData memory decodedData = abi.decode(data, (MyCallbackData));
        (bool success, bytes memory result) = decodedData.pool.call(
            abi.encodeWithSelector(
                decodedData.selector,
                SOME_AMOUNT,
                tokenOut,
                decodedData.caller,
                new bytes(0)
            )
        );
        if (!success) {
            if (result.length == 0) revert();
            assembly {
                revert(add(32, result), mload(result))
            }
        }
    }

    function exploitSwapNative(
        address pool,
        address tokenOut,
        uint256 amountOut,
        address to
    ) external {
        IvPair(pool).swapNative(
            amountOut,
            tokenOut,
            to,
            abi.encode(
                MyCallbackData({
                    caller: msg.sender,
                    pool: pool,
                    selector: IvPair.swapNative.selector
                })
            )
        );
    }

    function exploitSwapNativeToReserve(
        address pool,
        address tokenOut,
        uint256 amountOut,
        address to
    ) external {
        IvPair(pool).swapNativeToReserve(
            amountOut,
            tokenOut,
            to,
            abi.encode(
                MyCallbackData({
                    caller: msg.sender,
                    pool: pool,
                    selector: IvPair.swapNativeToReserve.selector
                })
            )
        );
    }

    function exploitSwapReserveToNative(
        address pool,
        address ikAddress,
        uint256 amountOut,
        address to
    ) external {
        IvPair(pool).swapReserveToNative(
            amountOut,
            ikAddress,
            to,
            abi.encode(
                MyCallbackData({
                    caller: msg.sender,
                    pool: pool,
                    selector: IvPair.swapReserveToNative.selector
                })
            )
        );
    }
}
